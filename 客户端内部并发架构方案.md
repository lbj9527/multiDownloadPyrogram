# 客户端内部并发架构方案

## 🎯 核心目标

在每个客户端内部实现下载和上传同时进行，保证媒体组完整性。

## 🔍 关键发现

### 媒体组格式保持的核心函数

- **`_handle_media_group_task`** (services/upload_service.py:197)：媒体组缓存和触发
- **`_upload_cached_media_group`** (services/upload_service.py:245)：批量上传保持格式
- **核心 API**：`client.send_media_group()` 保持媒体组格式

## 🔄 简化并发架构

### 客户端内部并发流程

```
每个客户端内部：
┌─────────────────────────────────────────┐
│ 客户端处理消息列表                        │
│                                         │
│ 消息1 → 下载 → 立即放入队列               │
│ 消息2 → 下载 → 立即放入队列               │
│ 消息3 → 下载 → 立即放入队列               │
│   ↓                    ↓                │
│ 继续下载下一条      上传消费者             │
│                   (媒体组缓存+批量上传)    │
└─────────────────────────────────────────┘

关键：下载完成立即入队，不等待上传
```

## 🔧 最小修改实现

### 在存储策略中添加简单队列

```python
class UploadStorageStrategy:
    def __init__(self, upload_handler):
        self.upload_handler = upload_handler
        # 添加简单的异步队列
        self.upload_queue = asyncio.Queue(maxsize=100)
        self.upload_task = None

        # 复用现有媒体组处理状态
        self.current_media_group_id = None
        self.media_group_cache = []

    async def process_message(self, client, message, channel, message_handler):
        """下载完成后立即入队，不等待上传"""
        # 下载消息（复用现有逻辑）
        if message_handler.has_media(message):
            media_data = await message_handler._download_media_to_memory(client, message)
            if not media_data:
                return False
        else:
            media_data = None

        # 创建上传任务
        upload_task = {
            'message': message,
            'media_data': media_data,
            'client': client
        }

        # 立即入队，不等待上传
        await self.upload_queue.put(upload_task)

        # 启动上传消费者（如果还没启动）
        if not self.upload_task:
            self.upload_task = asyncio.create_task(self._upload_consumer())

        return True  # 立即返回，上传在后台进行

    async def _upload_consumer(self):
        """上传消费者 - 复用现有媒体组处理逻辑"""
        while True:
            try:
                task = await self.upload_queue.get()

                # 直接调用现有的媒体组处理逻辑
                await self._handle_media_group_upload(task)

            except Exception as e:
                logger.error(f"上传消费者异常: {e}")

    async def _handle_media_group_upload(self, task):
        """复用现有的媒体组处理逻辑"""
        message = task['message']
        media_group_id = getattr(message, 'media_group_id', None)

        # 完全复用现有逻辑
        if media_group_id:
            # 检查媒体组ID变化
            if self.current_media_group_id != media_group_id:
                # 上传当前缓存的媒体组
                if self.current_media_group_id and self.media_group_cache:
                    await self._upload_current_media_group()

                # 开始新媒体组
                self.current_media_group_id = media_group_id
                self.media_group_cache = []

            # 缓存当前消息
            self.media_group_cache.append(task)
        else:
            # 单条消息，先上传缓存的媒体组
            if self.media_group_cache:
                await self._upload_current_media_group()

            # 直接上传单条消息
            await self.upload_handler.handle_upload(
                task['client'], message, media_data=task['media_data']
            )

    async def _upload_current_media_group(self):
        """上传当前缓存的媒体组 - 调用现有函数"""
        if not self.media_group_cache:
            return

        # 直接调用现有的上传服务逻辑
        # 这里复用 upload_service 的 send_media_group 功能
        await self.upload_handler.upload_media_group(self.media_group_cache)

        # 清理缓存
        self.current_media_group_id = None
        self.media_group_cache = []
```

### 程序结束时清理

```python
async def cleanup(self):
    """程序结束时清理剩余缓存"""
    # 停止接收新任务
    if self.upload_task:
        self.upload_task.cancel()

    # 上传剩余的媒体组
    if self.media_group_cache:
        await self._upload_current_media_group()
```

## 🎯 关键优势

### 1. 最小修改

- **只修改存储策略**：在现有 `UploadStorageStrategy` 中添加队列
- **复用现有逻辑**：直接使用现有的媒体组处理机制
- **保持架构不变**：不修改消息分组和任务分配

### 2. 真正并发

- **下载不等待上传**：下载完成立即入队，继续下载下一条
- **客户端内部并发**：每个客户端内部下载和上传同时进行
- **保持媒体组完整性**：复用现有的缓存和触发逻辑

## 📊 预期效果

- **性能提升**：理论提升 2-3 倍处理速度
- **媒体组保证**：使用现有的 `send_media_group` 机制保持格式
- **向后兼容**：raw 模式完全不受影响

## 🚀 实施方案

### 修改文件

只需修改 `core/storage_strategies.py` 中的 `UploadStorageStrategy` 类：

1. 添加 `asyncio.Queue` 队列
2. 添加上传消费者任务
3. 复用现有媒体组处理逻辑
4. 添加程序结束时的清理机制

### 使用方式

程序使用方式完全不变，会自动在客户端内部实现并发处理。
